program      : block EOF ;
expr         : definition
             | func
             | pair
             | cond
             | and
             | or
             | not
             | compare
             | add_sub_join
             | mod_div_mul
             | exponent
             | negate
             | apply
             | dot
             | list
             | group
             | scalar
             ;

definition   : "let" NAME "(" parameters ")" [ "->" type ] body_clause
             | "let" NAME [ ":" type ] body_clause
             ;
func         : "\" parameters "->" expr ;
pair         : expr "," expr ;
cond         : "if" and "then" expr "else" expr ;
and          : expr "and" expr ;
or           : expr "or" expr ;
not          : "not" expr ;
compare      : expr ( ">" | "<" | ">=" | "<=" | "=" | "/=" ) expr ;
add_sub_join : expr ( "+" | "-" | "<>" ) expr ;
mod_div_mul  : expr ( "*" | "/" | "%" ) expr ;
exponent     : expr { "^" expr } ;
negate       : "-" expr ;
apply        : expr { "(" expr { "," expr } [ "," ] ")" } ;
dot          : expr { "." NAME } ;
list         : "[" [ expr [ "," expr ] [ "," ] ] "]" ;
group        : "(" [ expr ] ")" ;
scalar       : bool
             | FLOAT
             | INTEGER
             | NAME
             | STRING
             ;
bool         : "True" | "False" ;

block        : { expr EOL } ;
body_clause  : "=" expr
             | ":=" block "end"
             ;
parameters   : NAME [ ":" type ] { "," NAME [ ":" type ] } [ "," ] ;
/* NOTE: Functions must have at least 1 parameter. */

type         : arrow_type ;
arrow_type   : tuple_type [ "->" arrow_type ] ;
tuple_type   : "(" [ type { "," type } [ "," ] ] ")"
             | generic
             ;
generic      : NAME [ "[" type { "," type } [ "," ] "]" ] ;
